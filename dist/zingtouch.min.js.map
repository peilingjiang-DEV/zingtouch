{"version":3,"sources":["webpack://ZingTouch/webpack/universalModuleDefinition","webpack://ZingTouch/webpack/bootstrap","webpack://ZingTouch/./src/core/classes/Binder.js","webpack://ZingTouch/./src/core/util.js","webpack://ZingTouch/./src/gestures/Gesture.js","webpack://ZingTouch/./src/core/dispatcher.js","webpack://ZingTouch/./src/core/interpreter.js","webpack://ZingTouch/./src/core/arbiter.js","webpack://ZingTouch/./src/gestures/Pan.js","webpack://ZingTouch/./src/gestures/Distance.js","webpack://ZingTouch/./src/gestures/Rotate.js","webpack://ZingTouch/./src/gestures/Swipe.js","webpack://ZingTouch/./src/gestures/Tap.js","webpack://ZingTouch/./src/core/classes/Binding.js","webpack://ZingTouch/./src/core/classes/ZingEvent.js","webpack://ZingTouch/./src/core/classes/Input.js","webpack://ZingTouch/./src/core/classes/State.js","webpack://ZingTouch/./src/core/classes/Region.js","webpack://ZingTouch/./src/ZingTouch.js","webpack://ZingTouch/./src/core/main.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Binder","element","bindOnce","state","this","keys","registeredGestures","forEach","handler","capture","addBinding","util","normalizeEvent","freeze","mousedown","touchstart","pointerdown","mousemove","touchmove","pointermove","mouseup","touchend","pointerup","isWithin","currentX","currentY","previousX","previousY","tolerance","Math","abs","distanceBetweenTwoPoints","x0","x1","y0","y1","hypot","getMidpoint","x","y","getAngle","originX","originY","projectionX","projectionY","atan2","getAngularDistance","start","end","getVelocity","startX","startY","startTime","endX","endY","endTime","getRightMostInput","inputs","rightMost","distance","Number","MIN_VALUE","input","initial","isInteger","isInside","target","rect","getBoundingClientRect","left","width","top","height","getPropagationPath","event","path","node","document","push","parentNode","getPathIndex","index","length","obj","setMSPreventDefault","style","removeMSPreventDefault","preventDefault","returnValue","Gesture","type","id","every","dispatcher","binding","data","events","newEvent","CustomEvent","gesture","getId","detail","bubbles","cancelable","dispatchEvent","ZingTouch","unbind","getType","emitEvent","interpreter","bindings","evType","map","current","reduce","accumulator","arbiter","region","eventType","buttons","updateInputs","retrieveBindingsByInitialPos","toBeDispatched","gestures","endCount","getCurrentEventType","resetInputs","Pan","options","numInputs","threshold","onStart","onMove","onEnd","progress","getGestureProgress","active","lastEmitted","output","reachedThreshold","distanceFromOrigin","currentDistance","directionFromOrigin","currentDirection","change","currentDegree","PI","degreeFromOrigin","packData","Distance","isValid","lastEmittedDistance","numActiveInputs","centerPoint","movement","center","Rotate","currentPivot","bRect","currentAngle","initialAngle","previousAngle","rotate","angle","distanceFromLast","Swipe","maxRestTime","escapeVelocity","timeDistortion","maxProgressStack","moves","time","Date","getTime","shift","currentMove","pop","lastMove","velocity","duration","Tap","minDelay","maxDelay","previous","resetProgress","MAX_VALUE","interval","timing","Binding","ZingEvent","touchIdentifier","eventObj","originalEvent","touches","changedTouches","Array","from","find","identifier","clientX","clientY","pageX","pageY","screenX","screenY","Input","currentEvent","State","regionId","numGestures","registerGesture","boundGesture","tagName","Error","indexOf","assignGestureId","addEventListener","filter","b","some","regionElement","pointerType","touch","update","pointerId","findInputById","setId","Region","PointerEvent","TouchEvent","e","retrieveBindingsByElement","unbound","removeEventListener","setType","registeredGesture","_regions"],"mappings":"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","file":"zingtouch.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZingTouch\"] = factory();\n\telse\n\t\troot[\"ZingTouch\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * @file Binder.js\n */\n\n/**\n * A chainable object that contains a single element to be bound upon.\n * Called from ZingTouch.bind(), and is used to chain over gesture callbacks.\n * @class\n */\nclass Binder {\n  /**\n   * Constructor function for the Binder class.\n   * @param {Element} element - The element to bind gestures to.\n   * @param {Boolean} bindOnce - Option to bind once and only emit\n   * the event once.\n   * @param {Object} state - The state of the Region that is being bound to.\n   * @return {Object} - Returns 'this' to be chained over and over again.\n   */\n  constructor(element, bindOnce, state) {\n    /**\n     * The element to bind gestures to.\n     * @type {Element}\n     */\n    this.element = element;\n\n    Object.keys(state.registeredGestures).forEach((key) => {\n      this[key] = (handler, capture) => {\n        state.addBinding(this.element, key, handler, capture, bindOnce);\n        return this;\n      };\n    });\n  }\n\n}\n\nexport default Binder;\n","/**\n * @file util.js\n * Various accessor and mutator functions to handle state and validation.\n */\n\n/**\n *  Contains generic helper functions\n * @type {Object}\n * @namespace util\n */\nlet util = {\n\n  /**\n   * Normalizes window events to be either of type start, move, or end.\n   * @param {String} type - The event type emitted by the browser\n   * @return {null|String} - The normalized event, or null if it is an\n   * event not predetermined.\n   */\n  normalizeEvent: Object.freeze({\n      mousedown:   'start',\n      touchstart:  'start',\n      pointerdown: 'start',\n\n      mousemove:   'move',\n      touchmove:   'move',\n      pointermove: 'move',\n\n      mouseup:   'end',\n      touchend:  'end',\n      pointerup: 'end',\n  }),\n  /* normalizeEvent*/\n\n  /**\n   * Determines if the current and previous coordinates are within or\n   * up to a certain tolerance.\n   * @param {Number} currentX - Current event's x coordinate\n   * @param {Number} currentY - Current event's y coordinate\n   * @param {Number} previousX - Previous event's x coordinate\n   * @param {Number} previousY - Previous event's y coordinate\n   * @param {Number} tolerance - The tolerance in pixel value.\n   * @return {boolean} - true if the current coordinates are\n   * within the tolerance, false otherwise\n   */\n  isWithin(currentX, currentY, previousX, previousY, tolerance) {\n    return ((Math.abs(currentY - previousY) <= tolerance) &&\n    (Math.abs(currentX - previousX) <= tolerance));\n  },\n  /* isWithin*/\n\n  /**\n   * Calculates the distance between two points.\n   * @param {Number} x0\n   * @param {Number} x1\n   * @param {Number} y0\n   * @param {Number} y1\n   * @return {number} The numerical value between two points\n   */\n  distanceBetweenTwoPoints(x0, x1, y0, y1) {\n    return Math.hypot(x1 - x0, y1 - y0);\n  },\n\n  /**\n   * Calculates the midpoint coordinates between two points.\n   * @param {Number} x0\n   * @param {Number} x1\n   * @param {Number} y0\n   * @param {Number} y1\n   * @return {Object} The coordinates of the midpoint.\n   */\n  getMidpoint(x0, x1, y0, y1) {\n    return {\n      x: ((x0 + x1) / 2),\n      y: ((y0 + y1) / 2),\n    };\n  },\n\n  /**\n   * Calculates the angle between the projection and an origin point.\n   *   |                (projectionX,projectionY)\n   *   |             /°\n   *   |          /\n   *   |       /\n   *   |    / θ\n   *   | /__________\n   *   ° (originX, originY)\n   * @param {number} originX\n   * @param {number} originY\n   * @param {number} projectionX\n   * @param {number} projectionY\n   * @return {number} - Radians along the unit circle where the projection lies\n   */\n  getAngle(originX, originY, projectionX, projectionY) {\n    return Math.atan2(projectionY - originY, projectionX - originX);\n  },\n\n  /**\n   * Calculates the angular distance in radians between two angles along the\n   * unit circle\n   * @param {number} start - The starting point in radians\n   * @param {number} end - The ending point in radians\n   * @return {number} The number of radians between the starting point and\n   * ending point.\n   */\n  getAngularDistance(start, end) {\n    return end - start;\n  },\n\n  /**\n   * Calculates the velocity of pixel/milliseconds between two points\n   * @param {Number} startX\n   * @param {Number} startY\n   * @param {Number} startTime\n   * @param {Number} endX\n   * @param {Number} endY\n   * @param {Number} endTime\n   * @return {Number} velocity of px/time\n   */\n  getVelocity(startX, startY, startTime, endX, endY, endTime) {\n    let distance = this.distanceBetweenTwoPoints(startX, endX, startY, endY);\n    return (distance / (endTime - startTime));\n  },\n\n  /**\n   * Returns the farthest right input\n   * @param {Array} inputs\n   * @return {Object}\n   */\n  getRightMostInput(inputs) {\n    let rightMost = null;\n    let distance = Number.MIN_VALUE;\n    inputs.forEach((input) => {\n      if (input.initial.x > distance) {\n        rightMost = input;\n      }\n    });\n    return rightMost;\n  },\n\n  /**\n   * Determines is the value is an integer and not a floating point\n   * @param {Mixed} value\n   * @return {boolean}\n   */\n  isInteger(value) {\n    return (typeof value === 'number') && (value % 1 === 0);\n  },\n\n  /**\n   * Determines if the x,y position of the input is within then target.\n   * @param {Number} x -clientX\n   * @param {Number} y -clientY\n   * @param {Element} target\n   * @return {Boolean}\n   */\n  isInside(x, y, target) {\n    const rect = target.getBoundingClientRect();\n    return ((x > rect.left && x < rect.left + rect.width) &&\n    (y > rect.top && y < rect.top + rect.height));\n  },\n  /**\n   * Polyfill for event.propagationPath\n   * @param {Event} event\n   * @return {Array}\n   */\n  getPropagationPath(event) {\n    if (event.path) {\n      return event.path;\n    } else {\n      let path = [];\n      let node = event.target;\n      while (node != document) {\n        path.push(node);\n        node = node.parentNode;\n      }\n\n      return path;\n    }\n  },\n\n  /**\n   * Retrieve the index inside the path array\n   * @param {Array} path\n   * @param {Element} element\n   * @return {Element}\n   */\n  getPathIndex(path, element) {\n    let index = path.length;\n\n    path.forEach((obj, i) => {\n      if (obj === element) {\n        index = i;\n      }\n    });\n\n    return index;\n  },\n\n  setMSPreventDefault(element) {\n    element.style['-ms-content-zooming'] = 'none';\n    element.style['touch-action'] = 'none';\n  },\n\n  removeMSPreventDefault(element) {\n    element.style['-ms-content-zooming'] = '';\n    element.style['touch-action'] = '';\n  },\n\n  preventDefault(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n  }\n};\n\nexport default util;\n","/**\n * @file Gesture.js\n * Contains the Gesture class\n */\n\nimport util from './../core/util.js';\n\n/**\n * The Gesture class that all gestures inherit from.\n */\nclass Gesture {\n  /**\n   * Constructor function for the Gesture class.\n   * @class Gesture\n   */\n  constructor() {\n    /**\n     * The generic string type of gesture ('expand'|'distance'|\n     *  'rotate'|'swipe'|'tap').\n     * @type {String}\n     */\n    this.type = null;\n\n    /**\n     * The unique identifier for each gesture determined at bind time by the\n     * state object. This allows for distinctions across instance variables of\n     * Gestures that are created on the fly (e.g. Tap-1, Tap-2, etc).\n     * @type {String|null}\n     */\n    this.id = null;\n  }\n\n  /**\n   * Set the type of the gesture to be called during an event\n   * @param {String} type - The unique identifier of the gesture being created.\n   */\n  setType(type) {\n    this.type = type;\n  }\n\n  /**\n   * getType() - Returns the generic type of the gesture\n   * @return {String} - The type of gesture\n   */\n  getType() {\n    return this.type;\n  }\n\n  /**\n   * Set the id of the gesture to be called during an event\n   * @param {String} id - The unique identifier of the gesture being created.\n   */\n  setId(id) {\n    this.id = id;\n  }\n\n  /**\n   * Return the id of the event. If the id does not exist, return the type.\n   * @return {String}\n   */\n  getId() {\n    return (this.id !== null) ? this.id : this.type;\n  }\n\n  /**\n   * Updates internal properties with new ones, only if the properties exist.\n   * @param {Object} object\n   */\n  update(object) {\n    Object.keys(object).forEach( key => {\n      this[key] = object[key];\n    });\n  }\n\n  /**\n   * start() - Event hook for the start of a gesture\n   * @param {Array} inputs - The array of Inputs on the screen\n\t * @param {Object} state - The state object of the current region.\n\t * @param {Element} element - The element associated to the binding.\n   * @return {null|Object}  - Default of null\n   */\n  start(inputs, state, element) {\n    return null;\n  }\n\n  /**\n   * move() - Event hook for the move of a gesture\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null|Object} - Default of null\n   */\n  move(inputs, state, element) {\n    return null;\n  }\n\n  /**\n   * end() - Event hook for the move of a gesture\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @return {null|Object}  - Default of null\n   */\n  end(inputs) {\n    return null;\n  }\n\n\t/**\n\t* isValid() - Pre-checks to ensure the invariants of a gesture are satisfied.\n\t* @param {Array} inputs - The array of Inputs on the screen\n\t* @param {Object} state - The state object of the current region.\n\t* @param {Element} element - The element associated to the binding.\n\t* @return {boolean} - If the gesture is valid\n\t*/\n\tisValid(inputs, state, element) {\n    return inputs.every( input => {\n        return util.isInside(input.initial.x, input.initial.y, element);\n    });\n  }\n\n}\n\nexport default Gesture;\n","/**\n * @file dispatcher.js\n * Contains logic for the dispatcher\n */\n\n/**\n * Emits data at the target element if available, and bubbles up from\n * the target to the parent until the document has been reached.\n * Called from the arbiter.\n * @param {Binding} binding - An object of type Binding\n * @param {Object} data - The metadata computed by the gesture being emitted.\n * @param {Array} events - An array of ZingEvents\n *  corresponding to the inputs on the screen.\n */\nfunction dispatcher(binding, data, events) {\n  data.events = events;\n\n  const newEvent = new CustomEvent(binding.gesture.getId(), {\n    detail: data,\n    bubbles: true,\n    cancelable: true,\n  });\n  emitEvent(binding.element, newEvent, binding);\n}\n\n/**\n * Emits the new event. Unbinds the event if the event was registered\n * at bindOnce.\n * @param {Element} target - Element object to emit the event to.\n * @param {Event} event - The CustomEvent to emit.\n * @param {Binding} binding - An object of type Binding\n */\nfunction emitEvent(target, event, binding) {\n  target.dispatchEvent(event);\n  if (binding.bindOnce) {\n    ZingTouch.unbind(binding.element, binding.gesture.getType());\n  }\n}\n\nexport default dispatcher;\n","/**\n * @file interpreter.js\n * Contains logic for the interpreter\n */\n\nimport util from './util.js';\n\n/**\n * Receives an event and an array of Bindings (element -> gesture handler)\n * to determine what event will be emitted. Called from the arbiter.\n * @param {Array} bindings - An array containing Binding objects\n * that associate the element to an event handler.\n * @param {Object} event - The event emitted from the window.\n * @param {Object} state - The state object of the current listener.\n * @return {Object | null} - Returns an object containing a binding and\n * metadata, or null if a gesture will not be emitted.\n */\nfunction interpreter(bindings, event, state) {\n  const evType = util.normalizeEvent[ event.type ];\n  const events = state.inputs.map( input => input.current );\n\n  const candidates = bindings.reduce( (accumulator, binding) => {\n    const data = binding.gesture[evType](state.inputs, state, binding.element);\n    if (data) accumulator.push({ binding, data, events });\n    return accumulator;\n  }, []);\n\n  return candidates;\n}\n\nexport default interpreter;\n","/**\n * @file arbiter.js\n * Contains logic for the dispatcher\n */\n\nimport dispatcher from './dispatcher.js';\nimport interpreter from './interpreter.js';\nimport util from './util.js';\n\n/**\n * Function that handles event flow, negotiating with the interpreter,\n * and dispatcher.\n * 1. Receiving all touch events in the window.\n * 2. Determining which gestures are linked to the target element.\n * 3. Negotiating with the Interpreter what event should occur.\n * 4. Sending events to the dispatcher to emit events to the target.\n * @param {Event} event - The event emitted from the window object.\n * @param {Object} region - The region object of the current listener.\n */\nfunction arbiter(event, region) {\n  const state = region.state;\n  const eventType = util.normalizeEvent[ event.type ];\n\n  /*\n   Return if a gesture is not in progress and won't be. Also catches the case\n   where a previous event is in a partial state (2 finger pan, waits for both\n   inputs to reach touchend)\n   */\n  if (state.inputs.length === 0 && eventType !== 'start') {\n    return;\n  }\n\n  /*\n   Check for 'stale' or events that lost focus\n   (e.g. a pan goes off screen/off region.)\n   Does not affect mobile devices.\n   */\n  if (typeof event.buttons !== 'undefined' &&\n    eventType !== 'end' &&\n    event.buttons === 0) {\n    state.resetInputs();\n    return;\n  }\n\n  // Update the state with the new events. If the event is stopped, return;\n  if (!state.updateInputs(event, region.element)) {\n    return;\n  }\n\n  // Retrieve the initial target from any one of the inputs\n  const bindings = state.retrieveBindingsByInitialPos();\n  if (bindings.length > 0) {\n    if (region.preventDefault) {\n      util.setMSPreventDefault(region.element);\n      util.preventDefault(event);\n    } else {\n      util.removeMSPreventDefault(region.element);\n    }\n\n    const toBeDispatched = {};\n    const gestures = interpreter(bindings, event, state);\n\n    /* Determine the deepest path index to emit the event\n     from, to avoid duplicate events being fired. */\n\n    const path = util.getPropagationPath(event);\n    gestures.forEach((gesture) => {\n      const id = gesture.binding.gesture.getId();\n      if (toBeDispatched[id]) {\n        if (util.getPathIndex(path, gesture.binding.element) <\n          util.getPathIndex(path, toBeDispatched[id].binding.element)) {\n          toBeDispatched[id] = gesture;\n        }\n      } else {\n        toBeDispatched[id] = gesture;\n      }\n    });\n\n    Object.keys(toBeDispatched).forEach((index) => {\n      const gesture = toBeDispatched[index];\n      dispatcher(gesture.binding, gesture.data, gesture.events);\n    });\n  }\n\n  let endCount = 0;\n  state.inputs.forEach((input) => {\n    if (input.getCurrentEventType() === 'end') {\n      endCount++;\n    }\n  });\n\n  if (endCount === state.inputs.length) {\n    state.resetInputs();\n  }\n}\n\nexport default arbiter;\n","/**\n * @file Pan.js\n * Contains the Pan class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MIN_THRESHOLD = 1;\n\n/**\n * A Pan is defined as a normal movement in any direction on a screen.\n * Pan gestures do not track start events and can interact with distance gestures\n * @class Pan\n */\nclass Pan extends Gesture {\n  /**\n   * Constructor function for the Pan class.\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.numInputs=1] - Number of inputs for the\n   *  Pan gesture.\n   * @param {Number} [options.threshold=1] - The minimum number of\n   * pixels the input has to move to trigger this gesture.\n   * @param {Function} [options.onStart] - The on start callback\n   * @param {Function} [options.onMove] - The on move callback\n   * @param {Function} [options.onEnd] - The on end callback\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'pan';\n\n    /**\n     * The number of inputs to trigger a Pan can be variable,\n     * and the maximum number being a factor of the browser.\n     * @type {Number}\n     */\n    this.numInputs = (options && options.numInputs) ?\n      options.numInputs : DEFAULT_INPUTS;\n\n    /**\n     * The minimum amount in pixels the pan must move until it is fired.\n     * @type {Number}\n     */\n    this.threshold = (options && options.threshold) ?\n      options.threshold : DEFAULT_MIN_THRESHOLD;\n\n    /**\n     * The on start callback\n     */\n    if (options && options.onStart && typeof options.onStart === 'function') {\n      this.onStart = options.onStart\n    }\n    /**\n     * The on move callback\n     */\n    if (options && options.onMove && typeof options.onMove === 'function') {\n      this.onMove = options.onMove\n    }\n    /**\n     * The on end callback\n     */\n    if (options && options.onEnd && typeof options.onEnd === 'function') {\n      this.onEnd = options.onEnd\n    }\n  }\n\n  /**\n   * Event hook for the start of a gesture. Marks each input as active,\n   * so it can invalidate any end events.\n   * @param {Array} inputs\n   */\n  start(inputs) {\n    inputs.forEach((input) => {\n      const progress = input.getGestureProgress(this.getId());\n      progress.active = true;\n      progress.lastEmitted = {\n        x: input.current.x,\n        y: input.current.y,\n      };\n    });\n    if(this.onStart) {\n      this.onStart(inputs);\n    }\n  }\n\n  /**\n   * move() - Event hook for the move of a gesture.\n   * Fired whenever the input length is met, and keeps a boolean flag that\n   * the gesture has fired at least once.\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {Object} - Returns the distance in pixels between the two inputs.\n   */\n  move(inputs, state, element) {\n    if (this.numInputs !== inputs.length) return null;\n\n    const output = {\n      data: [],\n    };\n\n    inputs.forEach( (input, index) => {\n      const progress = input.getGestureProgress(this.getId());\n      const distanceFromLastEmit = util.distanceBetweenTwoPoints(\n        progress.lastEmitted.x,\n        input.current.x,\n        progress.lastEmitted.y,\n        input.current.y\n      );\n      const reachedThreshold = distanceFromLastEmit >= this.threshold;\n      if (progress.active && reachedThreshold) {\n        output.data[index] = packData( input, progress );\n        progress.lastEmitted.x = input.current.x;\n        progress.lastEmitted.y = input.current.y;\n      }\n    });\n\n    if(this.onMove) {\n      this.onMove(inputs, state, element, output);\n    }\n    return output;\n\n    function packData( input, progress ) {\n      const distanceFromOrigin = util.distanceBetweenTwoPoints(\n        input.initial.x,\n        input.current.x,\n        input.initial.y,\n        input.current.y\n      );\n      const currentDistance = util.distanceBetweenTwoPoints(\n        progress.lastEmitted.x,\n        input.current.x,\n        progress.lastEmitted.y,\n        input.current.y\n      );\n      const directionFromOrigin = util.getAngle(\n        input.initial.x,\n        input.initial.y,\n        input.current.x,\n        input.current.y\n      );\n      const currentDirection = util.getAngle(\n        progress.lastEmitted.x,\n        progress.lastEmitted.y,\n        input.current.x,\n        input.current.y\n      );\n      const change = {\n        x: input.current.x - progress.lastEmitted.x,\n        y: input.current.y - progress.lastEmitted.y,\n      };\n      const currentDegree = currentDirection * 180 / Math.PI\n      const degreeFromOrigin = directionFromOrigin * 180 / Math.PI\n      return {\n        distanceFromOrigin,\n        currentDistance,\n        directionFromOrigin,\n        currentDirection,\n        change,\n        degreeFromOrigin,\n        currentDegree\n      };\n    }\n  }\n\n  /* move*/\n\n  /**\n   * end() - Event hook for the end of a gesture. If the gesture has at least\n   * fired once, then it ends on the first end event such that any remaining\n   * inputs will not trigger the event until all inputs have reached the\n   * touchend event. Any touchend->touchstart events that occur before all\n   * inputs are fully off the screen should not fire.\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @return {null} - null if the gesture is not to be emitted,\n   *  Object with information otherwise.\n   */\n  end(inputs) {\n    inputs.forEach((input) => {\n      const progress = input.getGestureProgress(this.getId());\n      progress.active = false;\n    });\n    if(this.onEnd) {\n      this.onEnd(inputs);\n    }\n    return null;\n  }\n\n  /* end*/\n}\n\nexport default Pan;\n","/**\n * @file Distance.js\n * Contains the abstract Distance class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 2;\nconst DEFAULT_MIN_THRESHOLD = 1;\n\n/**\n * A Distance is defined as two inputs moving either together or apart.\n * @class Distance\n */\nclass Distance extends Gesture {\n  /**\n   * Constructor function for the Distance class.\n   * @param {Object} options\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.threshold=1] - The minimum number of\n   *  pixels the input has to move to trigger this gesture.\n   * @param {Function} [options.onStart] - The on start callback\n   * @param {Function} [options.onMove] - The on move callback\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'distance';\n\n    /**\n     * The minimum amount in pixels the inputs must move until it is fired.\n     * @type {Number}\n     */\n    this.threshold = (options && options.threshold) ?\n      options.threshold : DEFAULT_MIN_THRESHOLD;\n\n    /**\n     * The on start callback\n     */\n    if (options && options.onStart && typeof options.onStart === 'function') {\n      this.onStart = options.onStart\n    }\n    /**\n     * The on move callback\n     */\n    if (options && options.onMove && typeof options.onMove === 'function') {\n      this.onMove = options.onMove\n    }\n  }\n\n  /**\n   * Event hook for the start of a gesture. Initialized the lastEmitted\n   * gesture and stores it in the first input for reference events.\n   * @param {Array} inputs\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   */\n  start(inputs, state, element) {\n    if(!this.isValid(inputs, state, element)) {\n      return null;\n    }\n    if (inputs.length === DEFAULT_INPUTS) {\n      // Store the progress in the first input.\n      const progress = inputs[0].getGestureProgress(this.getId());\n      progress.lastEmittedDistance = util.distanceBetweenTwoPoints(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n    }\n    if(this.onStart) {\n      this.onStart(inputs, state, element);\n    }\n  }\n\n  /**\n   * Event hook for the move of a gesture.\n   *  Determines if the two points are moved in the expected direction relative\n   *  to the current distance and the last distance.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {Object | null} - Returns the distance in pixels between two inputs\n   */\n  move(inputs, state, element) {\n    if (state.numActiveInputs() === DEFAULT_INPUTS) {\n      const currentDistance = util.distanceBetweenTwoPoints(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n      const centerPoint = util.getMidpoint(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n\n      // Progress is stored in the first input.\n      const progress = inputs[0].getGestureProgress(this.getId());\n      const change = currentDistance - progress.lastEmittedDistance;\n\n      if (Math.abs(change) >= this.threshold) {\n        progress.lastEmittedDistance = currentDistance;\n        const movement = {\n          distance: currentDistance,\n          center: centerPoint,\n          change,\n        };\n        if(this.onMove) {\n          this.onMove(inputs, state, element, movement);\n        }\n        return movement;\n      }\n    }\n    return null;\n  }\n}\n\nexport default Distance;\n","/**\n * @file Rotate.js\n * Contains the Rotate class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 2;\n\n/**\n * A Rotate is defined as two inputs moving about a circle,\n * maintaining a relatively equal radius.\n * @class Rotate\n */\nclass Rotate extends Gesture {\n  /**\n   * Constructor function for the Rotate class.\n   */\n  constructor(options = {}) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'rotate';\n\n    /**\n     * The number of touches required to emit Rotate events.\n     * @type {Number}\n     */\n    this.numInputs = options.numInputs || DEFAULT_INPUTS;\n\n    /**\n     * The on move callback\n     */\n    if (options && options.onMove && typeof options.onMove === 'function') {\n      this.onMove = options.onMove\n    }\n  }\n\n  /**\n   * move() - Event hook for the move of a gesture. Obtains the midpoint of two\n   * the two inputs and calculates the projection of the right most input along\n   * a unit circle to obtain an angle. This angle is compared to the previously\n   * calculated angle to output the change of distance, and is compared to the\n   * initial angle to output the distance from the initial angle to the current\n   * angle.\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @param {Object} state - The state object of the current listener.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null} - null if this event did not occur\n   * @return {Object} obj.angle - The current angle along the unit circle\n   * @return {Object} obj.distanceFromOrigin - The angular distance travelled\n   * from the initial right most point.\n   * @return {Object} obj.distanceFromLast - The change of angle between the\n   * last position and the current position.\n   */\n  move(inputs, state, element) {\n    const numActiveInputs = state.numActiveInputs();\n    if (this.numInputs !== numActiveInputs) return null;\n\n    let currentPivot, initialPivot;\n    let input;\n    if (numActiveInputs === 1) {\n      const bRect = element.getBoundingClientRect();\n      currentPivot = {\n        x: bRect.left + bRect.width / 2,\n        y: bRect.top + bRect.height / 2,\n      };\n      initialPivot = currentPivot;\n      input = inputs[0];\n    } else {\n      currentPivot = util.getMidpoint(\n        inputs[0].current.x,\n        inputs[1].current.x,\n        inputs[0].current.y,\n        inputs[1].current.y);\n      input = util.getRightMostInput(inputs);\n    }\n\n    // Translate the current pivot point.\n    const currentAngle = util.getAngle(\n      currentPivot.x,\n      currentPivot.y,\n      input.current.x,\n      input.current.y);\n\n    const progress = input.getGestureProgress(this.getId());\n    if (!progress.initialAngle) {\n      progress.initialAngle = progress.previousAngle = currentAngle;\n      progress.distance = progress.change = 0;\n    } else {\n      progress.change = util.getAngularDistance(\n        progress.previousAngle,\n        currentAngle);\n      progress.distance = progress.distance + progress.change;\n    }\n\n    progress.previousAngle = currentAngle;\n    const rotate = {\n      angle: currentAngle,\n      distanceFromOrigin: progress.distance,\n      distanceFromLast: progress.change,\n    };\n    if(this.onMove) {\n      this.onMove(inputs, state, element, rotate);\n    }\n    return rotate;\n  }\n\n  /* move*/\n}\n\nexport default Rotate;\n","/**\n * @file Swipe.js\n * Contains the Swipe class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MAX_REST_TIME = 100;\nconst DEFAULT_ESCAPE_VELOCITY = 0.2;\nconst DEFAULT_TIME_DISTORTION = 100;\nconst DEFAULT_MAX_PROGRESS_STACK = 10;\n\n/**\n * A swipe is defined as input(s) moving in the same direction in an relatively\n * increasing velocity and leaving the screen at some point before it drops\n * below it's escape velocity.\n * @class Swipe\n */\nclass Swipe extends Gesture {\n\n  /**\n   * Constructor function for the Swipe class.\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.numInputs] - The number of inputs to trigger a\n   * Swipe can be variable, and the maximum number being a factor of the browser\n   *  move and current move events.\n   * @param {Number} [options.maxRestTime] - The maximum resting time a point\n   *  has between it's last\n   * @param {Number} [options.escapeVelocity] - The minimum velocity the input\n   *  has to be at to emit a swipe.\n   * @param {Number} [options.timeDistortion] - (EXPERIMENTAL) A value of time\n   *  in milliseconds to distort between events.\n   * @param {Number} [options.maxProgressStack] - (EXPERIMENTAL)The maximum\n   *  amount of move events to keep\n   * track of for a swipe.\n   */\n  constructor(options) {\n    super();\n    /**\n     * The type of the Gesture\n     * @type {String}\n     */\n    this.type = 'swipe';\n\n    /**\n     * The number of inputs to trigger a Swipe can be variable,\n     * and the maximum number being a factor of the browser.\n     * @type {Number}\n     */\n    this.numInputs = (options && options.numInputs) ?\n      options.numInputs : DEFAULT_INPUTS;\n\n    /**\n     * The maximum resting time a point has between it's last move and\n     * current move events.\n     * @type {Number}\n     */\n    this.maxRestTime = (options && options.maxRestTime) ?\n      options.maxRestTime : DEFAULT_MAX_REST_TIME;\n\n    /**\n     * The minimum velocity the input has to be at to emit a swipe.\n     * This is useful for determining the difference between\n     * a swipe and a pan gesture.\n     * @type {number}\n     */\n    this.escapeVelocity = (options && options.escapeVelocity) ?\n      options.escapeVelocity : DEFAULT_ESCAPE_VELOCITY;\n\n    /**\n     * (EXPERIMENTAL) A value of time in milliseconds to distort between events.\n     * Browsers do not accurately measure time with the Date constructor in\n     * milliseconds, so consecutive events sometimes display the same timestamp\n     * but different x/y coordinates. This will distort a previous time\n     * in such cases by the timeDistortion's value.\n     * @type {number}\n     */\n    this.timeDistortion = (options && options.timeDistortion) ?\n      options.timeDistortion : DEFAULT_TIME_DISTORTION;\n\n    /**\n     * (EXPERIMENTAL) The maximum amount of move events to keep track of for a\n     * swipe. This helps give a more accurate estimate of the user's velocity.\n     * @type {number}\n     */\n    this.maxProgressStack = (options && options.maxProgressStack) ?\n      options.maxProgressStack : DEFAULT_MAX_PROGRESS_STACK;\n\n    /**\n     * The on move callback\n     */\n    if (options && options.onMove && typeof options.onMove === 'function') {\n      this.onMove = options.onMove\n    }\n    /**\n     * The on end callback\n     */\n    if (options && options.onEnd && typeof options.onEnd === 'function') {\n      this.onEnd = options.onEnd\n    }\n  }\n\n  /**\n   * Event hook for the move of a gesture. Captures an input's x/y coordinates\n   * and the time of it's event on a stack.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null} - Swipe does not emit from a move.\n   */\n  move(inputs, state, element) {\n    if (this.numInputs === inputs.length) {\n      for (let i = 0; i < inputs.length; i++) {\n        let progress = inputs[i].getGestureProgress(this.getId());\n        if (!progress.moves) {\n          progress.moves = [];\n        }\n\n        progress.moves.push({\n          time: new Date().getTime(),\n          x: inputs[i].current.x,\n          y: inputs[i].current.y,\n        });\n\n        if (progress.length > this.maxProgressStack) {\n          progress.moves.shift();\n        }\n      }\n    }\n\n    if(this.onMove) {\n      this.onMove(inputs, state, element);\n    }\n\n    return null;\n  }\n\n  /* move*/\n\n  /**\n   * Determines if the input's history validates a swipe motion.\n   * Determines if it did not come to a complete stop (maxRestTime), and if it\n   * had enough of a velocity to be considered (ESCAPE_VELOCITY).\n   * @param {Array} inputs - The array of Inputs on the screen\n   * @return {null|Object} - null if the gesture is not to be emitted,\n   *  Object with information otherwise.\n   */\n  end(inputs) {\n    if (this.numInputs === inputs.length) {\n      let output = {\n        data: [],\n      };\n\n      for (let i = 0; i < inputs.length; i++) {\n        // Determine if all input events are on the 'end' event.\n        if (inputs[i].current.type !== 'end') {\n          return;\n        }\n\n        let progress = inputs[i].getGestureProgress(this.getId());\n        if (progress.moves && progress.moves.length > 2) {\n          // CHECK : Return if the input has not moved in maxRestTime ms.\n\n          let currentMove = progress.moves.pop();\n          if ((new Date().getTime()) - currentMove.time > this.maxRestTime) {\n            return null;\n          }\n\n          let lastMove;\n          let index = progress.moves.length - 1;\n\n          /* Date is unreliable, so we retrieve the last move event where\n           the time is not the same. */\n          while (index !== -1) {\n            if (progress.moves[index].time !== currentMove.time) {\n              lastMove = progress.moves[index];\n              break;\n            }\n\n            index--;\n          }\n\n          /* If the date is REALLY unreliable, we apply a time distortion\n           to the last event.\n           */\n          if (!lastMove) {\n            lastMove = progress.moves.pop();\n            lastMove.time += this.timeDistortion;\n          }\n\n          var velocity = util.getVelocity(lastMove.x, lastMove.y, lastMove.time,\n            currentMove.x, currentMove.y, currentMove.time);\n\n          output.data[i] = {\n            velocity: velocity,\n            distance: util.distanceBetweenTwoPoints(lastMove.x, currentMove.x, lastMove.y, currentMove.y),\n            duration:  currentMove.time - lastMove.time,\n            currentDirection: util.getAngle(\n              lastMove.x,\n              lastMove.y,\n              currentMove.x,\n              currentMove.y),\n          };\n        }\n      }\n\n      for (var i = 0; i < output.data.length; i++) {\n        if (velocity < this.escapeVelocity) {\n          return null;\n        }\n      }\n\n      if (output.data.length > 0) {\n        if(this.onEnd) {\n          this.onEnd(inputs, output);\n        }\n        return output;\n      }\n    }\n\n    return null;\n  }\n\n  /* end*/\n}\n\nexport default Swipe;\n","/**\n * @file Tap.js\n * Contains the Tap class\n */\n\nimport Gesture from './Gesture.js';\nimport util from './../core/util.js';\n\nconst DEFAULT_MIN_DELAY_MS = 0;\nconst DEFAULT_MAX_DELAY_MS = 300;\nconst DEFAULT_INPUTS = 1;\nconst DEFAULT_MOVE_PX_TOLERANCE = 10;\n\n/**\n * A Tap is defined as a touchstart to touchend event in quick succession.\n * @class Tap\n */\nclass Tap extends Gesture {\n  /**\n   * Constructor function for the Tap class.\n   * @param {Object} [options] - The options object.\n   * @param {Number} [options.minDelay=0] - The minimum delay between a\n   * touchstart and touchend can be configured in milliseconds.\n   * @param {Number} [options.maxDelay=300] - The maximum delay between a\n   * touchstart and touchend can be configured in milliseconds.\n   * @param {Number} [options.numInputs=1] - Number of inputs for Tap gesture.\n   * @param {Number} [options.tolerance=10] - The tolerance in pixels\n   *  a user can move.\n   * @param {Function} [options.onStart] - The on start callback\n   * @param {Function} [options.onMove] - The on move callback\n   * @param {Function} [options.onEnd] - The on end callback\n   */\n  constructor(options) {\n    super();\n\n    /**\n     * The type of the Gesture.\n     * @type {String}\n     */\n    this.type = 'tap';\n\n    /**\n     * The minimum amount between a touchstart and a touchend can be configured\n     * in milliseconds. The minimum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     * @type {Number}\n     */\n    this.minDelay = (options && options.minDelay) ?\n      options.minDelay : DEFAULT_MIN_DELAY_MS;\n\n    /**\n     * The maximum delay between a touchstart and touchend can be configured in\n     * milliseconds. The maximum delay starts to count down when the expected\n     * number of inputs are on the screen, and ends when ALL inputs are off the\n     * screen.\n     * @type {Number}\n     */\n    this.maxDelay = (options && options.maxDelay) ?\n      options.maxDelay : DEFAULT_MAX_DELAY_MS;\n\n    /**\n     * The number of inputs to trigger a Tap can be variable,\n     * and the maximum number being a factor of the browser.\n     * @type {Number}\n     */\n    this.numInputs = (options && options.numInputs) ?\n      options.numInputs : DEFAULT_INPUTS;\n\n    /**\n     * A move tolerance in pixels allows some slop between a user's start to end\n     * events. This allows the Tap gesture to be triggered more easily.\n     * @type {number}\n     */\n    this.tolerance = (options && options.tolerance) ?\n      options.tolerance : DEFAULT_MOVE_PX_TOLERANCE;\n\n    /**\n     * The on end callback\n     */\n    if (options && options.onEnd && typeof options.onEnd === 'function') {\n      this.onEnd = options.onEnd\n    }\n  }\n\n  /* constructor*/\n\n  /**\n   * Event hook for the start of a gesture. Keeps track of when the inputs\n   * trigger the start event.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @return {null} - Tap does not trigger on a start event.\n   */\n  start(inputs) {\n    if (inputs.length === this.numInputs) {\n      inputs.forEach((input) => {\n        let progress = input.getGestureProgress(this.getId());\n        progress.start = new Date().getTime();\n      });\n    }\n    return null;\n  }\n\n  /* start*/\n\n  /**\n   * Event hook for the move of a gesture. The Tap event reaches here if the\n   * user starts to move their input before an 'end' event is reached.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @param {Object} state - The state object of the current region.\n   * @param {Element} element - The element associated to the binding.\n   * @return {null} - Tap does not trigger on a move event.\n   */\n  move(inputs, state, element) {\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getCurrentEventType() === 'move') {\n        let current = inputs[i].current;\n        let previous = inputs[i].previous;\n        if (!util.isWithin(\n            current.x,\n            current.y,\n            previous.x,\n            previous.y,\n            this.tolerance)) {\n          let type = this.type;\n          inputs.forEach(function(input) {\n            input.resetProgress(type);\n          });\n\n          return null;\n        }\n      }\n    }\n    return null;\n  }\n\n  /* move*/\n\n  /**\n   * Event hook for the end of a gesture.\n   * Determines if this the tap event can be fired if the delay and tolerance\n   * constraints are met. Also waits for all of the inputs to be off the screen\n   * before determining if the gesture is triggered.\n   * @param {Array} inputs - The array of Inputs on the screen.\n   * @return {null|Object} - null if the gesture is not to be emitted,\n   * Object with information otherwise. Returns the interval time between start\n   * and end events.\n   */\n  end(inputs) {\n    if (inputs.length !== this.numInputs) {\n      return null;\n    }\n    let startTime = Number.MAX_VALUE;\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getCurrentEventType() !== 'end') {\n        return null;\n      }\n\n      let progress = inputs[i].getGestureProgress(this.getId());\n      if (!progress.start) {\n        return null;\n      }\n\n      // Find the most recent input's startTime\n      if (progress.start < startTime) {\n        startTime = progress.start;\n      }\n    }\n\n    let interval = new Date().getTime() - startTime;\n    if ((this.minDelay <= interval) && (this.maxDelay >= interval)) {\n\n      const timing = { interval }\n      if(this.onEnd) {\n        this.onEnd(inputs, timing);\n      }\n      return timing;\n    } else {\n      let type = this.type;\n      inputs.forEach(function(input) {\n        input.resetProgress(type);\n      });\n\n      return null;\n    }\n  }\n\n  /* end*/\n}\n\nexport default Tap;\n","/**\n * @file Binding.js\n */\n\n/**\n * Responsible for creating a binding between an element and a gesture.\n * @class Binding\n */\nclass Binding {\n  /**\n   * Constructor function for the Binding class.\n   * @param {Element} element - The element to associate the gesture to.\n   * @param {Gesture} gesture - A instance of the Gesture type.\n   * @param {Function} handler - The function handler to execute when a\n   * gesture is recognized\n   * on the associated element.\n   * @param {Boolean} [capture=false] - A boolean signifying if the event is\n   * to be emitted during\n   * the capture or bubble phase.\n   * @param {Boolean} [bindOnce=false] - A boolean flag\n   * used for the bindOnce syntax.\n   */\n  constructor(element, gesture, handler, capture, bindOnce) {\n    /**\n     * The element to associate the gesture to.\n     * @type {Element}\n     */\n    this.element = element;\n    /**\n     * A instance of the Gesture type.\n     * @type {Gesture}\n     */\n    this.gesture = gesture;\n    /**\n     * The function handler to execute when a gesture is\n     * recognized on the associated element.\n     * @type {Function}\n     */\n    this.handler = handler;\n\n    /**\n     * A boolean signifying if the event is to be\n     * emitted during the capture or bubble phase.\n     * @type {Boolean}\n     */\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\n\n    /**\n     * A boolean flag used for the bindOnce syntax.\n     * @type {Boolean}\n     */\n    this.bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\n  }\n\n}\n\nexport default Binding;\n","/**\n * @file ZingEvent.js\n * Contains logic for ZingEvents\n */\n\nimport util from '../util.js';\n\nconst INITIAL_COORDINATE = 0;\n/**\n * An event wrapper that normalizes events across browsers and input devices\n * @class ZingEvent\n */\nclass ZingEvent {\n  /**\n   * @constructor\n   * @param {Event} event - The event object being wrapped.\n   * @param {Array} event.touches - The number of touches on\n   *  a screen (mobile only).\n   * @param {Object} event.changedTouches - The TouchList representing\n   * points that participated in the event.\n   * @param {Number} touchIdentifier - The index of touch if applicable\n   */\n  constructor(event, touchIdentifier) {\n    /**\n     * The original event object.\n     * @type {Event}\n     */\n    this.originalEvent = event;\n\n    /**\n     * The type of event or null if it is an event not predetermined.\n     * @see util.normalizeEvent\n     * @type {String | null}\n     */\n    this.type = util.normalizeEvent[ event.type ];\n\n    /**\n     * The X coordinate for the event, based off of the client.\n     * @type {number}\n     */\n    this.x = INITIAL_COORDINATE;\n\n    /**\n     * The Y coordinate for the event, based off of the client.\n     * @type {number}\n     */\n    this.y = INITIAL_COORDINATE;\n\n    let eventObj;\n    if (event.touches && event.changedTouches) {\n      eventObj = Array.from(event.changedTouches).find( t => {\n        return t.identifier === touchIdentifier;\n      });\n    } else {\n      eventObj = event;\n    }\n\n    this.x = this.clientX = eventObj.clientX;\n    this.y = this.clientY = eventObj.clientY;\n\n    this.pageX = eventObj.pageX;\n    this.pageY = eventObj.pageY;\n\n    this.screenX = eventObj.screenX;\n    this.screenY = eventObj.screenY;\n  }\n}\n\nexport default ZingEvent;\n","/**\n * @file Input.js\n */\n\nimport ZingEvent from './ZingEvent.js';\n\n/**\n * Tracks a single input and contains information about the\n * current, previous, and initial events.\n * Contains the progress of each Input and it's associated gestures.\n * @class Input\n */\nclass Input {\n\n  /**\n   * Constructor function for the Input class.\n   * @param {Event} event - The Event object from the window\n   * @param {Number} [identifier=0] - The identifier for each input event\n   * (taken from event.changedTouches)\n   */\n  constructor(event, identifier) {\n    let currentEvent = new ZingEvent(event, identifier);\n\n    /**\n     * Holds the initial event object. A touchstart/mousedown event.\n     * @type {ZingEvent}\n     */\n    this.initial = currentEvent;\n\n    /**\n     * Holds the most current event for this Input, disregarding any other past,\n     * current, and future events that other Inputs participate in.\n     * e.g. This event ended in an 'end' event, but another Input is still\n     * participating in events -- this will not be updated in such cases.\n     * @type {ZingEvent}\n     */\n    this.current = currentEvent;\n\n    /**\n     * Holds the previous event that took place.\n     * @type {ZingEvent}\n     */\n    this.previous = currentEvent;\n\n    /**\n     * Refers to the event.touches index, or 0 if a simple mouse event occurred.\n     * @type {Number}\n     */\n    this.identifier = (typeof identifier !== 'undefined') ? identifier : 0;\n\n    /**\n     * Stores internal state between events for\n     * each gesture based off of the gesture's id.\n     * @type {Object}\n     */\n    this.progress = {};\n  }\n\n  /**\n   * Receives an input, updates the internal state of what the input has done.\n   * @param {Event} event - The event object to wrap with a ZingEvent.\n   * @param {Number} touchIdentifier - The index of inputs, from event.touches\n   */\n  update(event, touchIdentifier) {\n    this.previous = this.current;\n    this.current = new ZingEvent(event, touchIdentifier);\n  }\n\n  /**\n   * Returns the progress of the specified gesture.\n   * @param {String} id - The identifier for each unique Gesture's progress.\n   * @return {Object} - The progress of the gesture.\n   * Creates an empty object if no progress has begun.\n   */\n  getGestureProgress(id) {\n    if (!this.progress[id]) {\n      this.progress[id] = {};\n    }\n    return this.progress[id];\n  }\n\n  /**\n   * Returns the normalized current Event's type.\n   * @return {String} The current event's type ( start | move | end )\n   */\n  getCurrentEventType() {\n    return this.current.type;\n  }\n\n  /**\n   * Resets a progress/state object of the specified gesture.\n   * @param {String} id - The identifier of the specified gesture\n   */\n  resetProgress(id) {\n    this.progress[id] = {};\n  }\n\n}\n\nexport default Input;\n","/**\n * @file State.js\n */\n\nimport Gesture from './../../gestures/Gesture.js';\nimport Pan from './../../gestures/Pan.js';\nimport Distance from './../../gestures/Distance.js';\nimport Rotate from './../../gestures/Rotate.js';\nimport Swipe from './../../gestures/Swipe.js';\nimport Tap from './../../gestures/Tap.js';\nimport Binding from './Binding.js';\nimport Input from './Input.js';\nimport util from './../util.js';\n\nconst DEFAULT_MOUSE_ID = 0;\n\n/**\n * Creates an object related to a Region's state,\n * and contains helper methods to update and clean up different states.\n */\nclass State {\n\n  /**\n   * Constructor for the State class.\n   * @param {String} regionId - The id the region this state is bound to.\n   */\n  constructor(regionId) {\n    /**\n     * The id for the region this state is bound to.\n     * @type {String}\n     */\n    this.regionId = regionId;\n\n    /**\n     * An array of current and recently inactive\n     *  Input objects related to a gesture.\n     * @type {Input}\n     */\n    this.inputs = [];\n\n    /**\n     * An array of Binding objects; The list of relations between elements,\n     *   their gestures, and the handlers.\n     * @type {Binding}\n     */\n    this.bindings = [];\n\n    /**\n     * The number of gestures that have been registered with this state\n     * @type {Number}\n     */\n    this.numGestures = 0;\n\n    /**\n     * A key/value map all the registered gestures for the listener.\n     *  Note: Can only have one gesture registered to one key.\n     * @type {Object}\n     */\n    this.registeredGestures = {};\n\n    this.registerGesture(new Pan(), 'pan');\n    this.registerGesture(new Rotate(), 'rotate');\n    this.registerGesture(new Distance(), 'distance');\n    this.registerGesture(new Swipe(), 'swipe');\n    this.registerGesture(new Tap(), 'tap');\n  }\n\n  /**\n   * Creates a new binding with the given element and gesture object.\n   * If the gesture object provided is unregistered, it's reference\n   * will be saved in as a binding to be later referenced.\n   * @param  {Element} element - The element the gesture is bound to.\n   * @param {String|Object} gesture  - Either a name of a registered gesture,\n   *  or an unregistered  Gesture object.\n   * @param {Function} handler - The function handler to be called\n   *  when the event is emitted. Used to bind/unbind.\n   * @param {Boolean} capture - Whether the gesture is to be\n   *  detected in the capture of bubble phase. Used to bind/unbind.\n   * @param {Boolean} bindOnce - Option to bind once and\n   *  only emit the event once.\n   */\n  addBinding(element, gesture, handler, capture, bindOnce) {\n    let boundGesture;\n\n    // Error type checking.\n    if (element && typeof element.tagName === 'undefined') {\n      throw new Error('Parameter element is an invalid object.');\n    }\n\n    if (typeof handler !== 'function') {\n      throw new Error('Parameter handler is invalid.');\n    }\n\n    if (typeof gesture === 'string' &&\n      Object.keys(this.registeredGestures).indexOf(gesture) === -1) {\n      throw new Error('Parameter ' + gesture + ' is not a registered gesture');\n    } else if (typeof gesture === 'object' && !(gesture instanceof Gesture)) {\n      throw new Error('Parameter for the gesture is not of a Gesture type');\n    }\n\n    if (typeof gesture === 'string') {\n      boundGesture = this.registeredGestures[gesture];\n    } else {\n      boundGesture = gesture;\n      if (boundGesture.id === '') {\n        this.assignGestureId(boundGesture);\n      }\n    }\n\n    this.bindings.push(new Binding(element, boundGesture,\n      handler, capture, bindOnce));\n    element.addEventListener(boundGesture.getId(), handler, capture);\n  }\n\n  /**\n   * Retrieves the Binding by which an element is associated to.\n   * @param {Element} element - The element to find bindings to.\n   * @return {Array} - An array of Bindings to which that element is bound\n   */\n  retrieveBindingsByElement(element) {\n    return this.bindings.filter( b => b.element === element );\n  }\n\n  /**\n   * Retrieves all bindings based upon the initial X/Y position of the inputs.\n   * e.g. if gesture started on the correct target element,\n   *  but diverted away into the correct region, this would still be valid.\n   * @return {Array} - An array of Bindings to which that element is bound\n   */\n  retrieveBindingsByInitialPos() {\n    return this.bindings.filter( binding => {\n      return this.inputs.some( input => {\n        return util.isInside(input.initial.x, input.initial.y, binding.element);\n      });\n    });\n  }\n\n  /**\n   * Updates the inputs with new information based upon a new event being fired.\n   * @param {Event} event - The event being captured.\n   * @param {Element} regionElement - The element where\n   *  this current Region is bound to.\n   * @return {boolean} - returns true for a successful update,\n   *  false if the event is invalid.\n   */\n  updateInputs(event, regionElement) {\n    let eventType = (event.touches) ?\n      'TouchEvent' : ((event.pointerType) ? 'PointerEvent' : 'MouseEvent');\n    switch (eventType) {\n      case 'TouchEvent':\n        Array.from(event.changedTouches).forEach( touch => {\n          update(event, this, touch.identifier, regionElement);\n        });\n        break;\n\n      case 'PointerEvent':\n        update(event, this, event.pointerId, regionElement);\n        break;\n\n      case 'MouseEvent':\n      default:\n        update(event, this, DEFAULT_MOUSE_ID, regionElement);\n        break;\n    }\n    return true;\n\n    function update(event, state, identifier, regionElement) {\n      const eventType = util.normalizeEvent[ event.type ];\n      const input = findInputById(state.inputs, identifier);\n\n      // A starting input was not cleaned up properly and still exists.\n      if (eventType === 'start' && input) {\n        state.resetInputs();\n        return;\n      }\n\n      // An input has moved outside the region.\n      if (eventType !== 'start' &&\n        input &&\n        !util.isInside(input.current.x, input.current.y, regionElement)) {\n         state.resetInputs();\n        return;\n      }\n\n      if (eventType !== 'start' && !input) {\n        state.resetInputs();\n        return;\n      }\n\n      if (eventType === 'start') {\n        state.inputs.push(new Input(event, identifier));\n      } else {\n        input.update(event, identifier);\n      }\n    }\n  }\n\n  /**\n   * Removes all inputs from the state, allowing for a new gesture.\n   */\n  resetInputs() {\n    this.inputs = [];\n  }\n\n  /**\n   * Counts the number of active inputs at any given time.\n   * @return {Number} - The number of active inputs.\n   */\n  numActiveInputs() {\n    const endType = this.inputs.filter((input) => {\n      return input.current.type !== 'end';\n    });\n    return endType.length;\n  }\n\n  /**\n   * Register the gesture to the current region.\n   * @param {Object} gesture - The gesture to register\n   * @param {String} key - The key to define the new gesture as.\n   */\n  registerGesture(gesture, key) {\n    this.assignGestureId(gesture);\n    this.registeredGestures[key] = gesture;\n  }\n\n  /**\n   * Tracks the gesture to this state object to become uniquely identifiable.\n   * Useful for nested Regions.\n   * @param {Gesture} gesture - The gesture to track\n   */\n  assignGestureId(gesture) {\n    gesture.setId(this.regionId + '-' + this.numGestures++);\n  }\n\n}\n/**\n * Searches through each input, comparing the browser's identifier key\n *  for touches, to the stored one in each input\n * @param {Array} inputs - The array of inputs in state.\n * @param {String} identifier - The identifier the browser has assigned.\n * @return {Input} - The input object with the corresponding identifier,\n *  null if it did not find any.\n */\nfunction findInputById(inputs, identifier) {\n  return inputs.find( i => i.identifier === identifier );\n}\n\nexport default State;\n","/**\n * @file Region.js\n */\n\nimport Binder from './Binder.js';\nimport Gesture from './../../gestures/Gesture.js';\nimport arbiter from './../arbiter.js';\nimport State from './State.js';\n\n/**\n * Allows the user to specify a region to capture all events to feed ZingTouch\n * into. This can be as narrow as the element itself, or as big as the document\n * itself. The more specific an area, the better performant the overall\n * application will perform. Contains API methods to bind/unbind specific\n * elements to corresponding gestures. Also contains the ability to\n * register/unregister new gestures.\n * @class Region\n */\nclass Region {\n\n  /**\n   * Constructor function for the Region class.\n   * @param {Element} element - The element to capture all\n   *  window events in that region to feed into ZingTouch.\n   * @param {boolean} [capture=false] - Whether the region listens for\n   *  captures or bubbles.\n   * @param {boolean} [preventDefault=true] - Whether the default browser\n   *  functionality should be disabled;\n   * @param {Number} id - The id of the region, assigned by the ZingTouch object\n   */\n  constructor(element, capture, preventDefault, id) {\n    /**\n     * The identifier for the Region. This is assigned by the ZingTouch object\n     * and is used to hash gesture id for uniqueness.\n     * @type {Number}\n     */\n    this.id = id;\n\n    /**\n     * The element being bound to.\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the region listens for captures or bubbles.\n     * @type {boolean}\n     */\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\n\n    /**\n     * Boolean to disable browser functionality such as scrolling and zooming\n     * over the region\n     * @type {boolean}\n     */\n    this.preventDefault = (typeof preventDefault !== 'undefined') ?\n      preventDefault : true;\n\n    /**\n     * The internal state object for a Region.\n     * Keeps track of registered gestures, inputs, and events.\n     * @type {State}\n     */\n    this.state = new State(id);\n\n    let eventNames = [];\n    if (window.PointerEvent && !window.TouchEvent) {\n      eventNames = [\n        'pointerdown',\n        'pointermove',\n        'pointerup',\n      ];\n    } else {\n      eventNames = [\n        'mousedown',\n        'mousemove',\n        'mouseup',\n        'touchstart',\n        'touchmove',\n        'touchend',\n      ];\n    }\n\n    // Bind detected browser events to the region element.\n    eventNames.forEach((name) => {\n      element.addEventListener(name, (e) => {\n        arbiter(e, this);\n      }, this.capture);\n    });\n  }\n\n  /**\n   * Bind an element to a registered/unregistered gesture with\n   * multiple function signatures.\n   * @example\n   * bind(element) - chainable\n   * @example\n   * bind(element, gesture, handler, [capture])\n   * @param {Element} element - The element object.\n   * @param {String|Object} [gesture] - Gesture key, or a Gesture object.\n   * @param {Function} [handler] - The function to execute when an event is\n   *  emitted.\n   * @param {Boolean} [capture] - capture/bubble\n   * @param {Boolean} [bindOnce = false] - Option to bind once and\n   *  only emit the event once.\n   * @return {Object} - a chainable object that has the same function as bind.\n   */\n  bind(element, gesture, handler, capture, bindOnce) {\n    if (!element || (element && !element.tagName)) {\n      throw 'Bind must contain an element';\n    }\n\n    bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\n    if (!gesture) {\n      return new Binder(element, bindOnce, this.state);\n    } else {\n      this.state.addBinding(element, gesture, handler, capture, bindOnce);\n    }\n  }\n\n  /**\n   * Bind an element and sets up actions to remove the binding once\n   * it has been emitted for the first time.\n   * 1. bind(element) - chainable\n   * 2. bind(element, gesture, handler, [capture])\n   * @param {Element} element - The element object.\n   * @param {String|Object} gesture - Gesture key, or a Gesture object.\n   * @param {Function} handler - The function to execute when an\n   *  event is emitted.\n   * @param {Boolean} capture - capture/bubble\n   * @return {Object} - a chainable object that has the same function as bind.\n   */\n  bindOnce(element, gesture, handler, capture) {\n    this.bind(element, gesture, handler, capture, true);\n  }\n\n  /**\n   * Unbinds an element from either the specified gesture\n   *  or all if no element is specified.\n   * @param {Element} element -The element to remove.\n   * @param {String | Object} [gesture] - A String representing the gesture,\n   *   or the actual object being used.\n   * @return {Array} - An array of Bindings that were unbound to the element;\n   */\n  unbind(element, gesture) {\n    let bindings = this.state.retrieveBindingsByElement(element);\n    let unbound = [];\n\n    bindings.forEach((binding) => {\n      if (gesture) {\n        if (typeof gesture === 'string' &&\n          this.state.registeredGestures[gesture]) {\n          let registeredGesture = this.state.registeredGestures[gesture];\n          if (registeredGesture.id === binding.gesture.id) {\n            element.removeEventListener(\n              binding.gesture.getId(),\n              binding.handler, binding.capture);\n            unbound.push(binding);\n          }\n        }\n      } else {\n        element.removeEventListener(\n          binding.gesture.getId(),\n          binding.handler,\n          binding.capture);\n        unbound.push(binding);\n      }\n    });\n\n    return unbound;\n  }\n\n  /* unbind*/\n\n  /**\n   * Registers a new gesture with an assigned key\n   * @param {String} key - The key used to register an element to that gesture\n   * @param {Gesture} gesture - A gesture object\n   */\n  register(key, gesture) {\n    if (typeof key !== 'string') {\n      throw new Error('Parameter key is an invalid string');\n    }\n\n    if (!gesture instanceof Gesture) {\n      throw new Error('Parameter gesture is an invalid Gesture object');\n    }\n\n    gesture.setType(key);\n    this.state.registerGesture(gesture, key);\n  }\n\n  /* register*/\n\n  /**\n   * Un-registers a gesture from the Region's state such that\n   * it is no longer emittable.\n   * Unbinds all events that were registered with the type.\n   * @param {String|Object} key - Gesture key that was used to\n   *  register the object\n   * @return {Object} - The Gesture object that was unregistered\n   *  or null if it could not be found.\n   */\n  unregister(key) {\n    this.state.bindings.forEach((binding) => {\n      if (binding.gesture.getType() === key) {\n        binding.element.removeEventListener(binding.gesture.getId(),\n          binding.handler, binding.capture);\n      }\n    });\n\n    let registeredGesture = this.state.registeredGestures[key];\n    delete this.state.registeredGestures[key];\n    return registeredGesture;\n  }\n}\n\nexport default Region;\n","/**\n * @file ZingTouch.js\n * Main object containing API methods and Gesture constructors\n */\n\nimport Region from './core/classes/Region.js';\nimport Gesture from './gestures/Gesture.js';\nimport Pan from './gestures/Pan.js';\nimport Distance from './gestures/Distance.js';\nimport Rotate from './gestures/Rotate.js';\nimport Swipe from './gestures/Swipe.js';\nimport Tap from './gestures/Tap.js';\n\n/**\n * The global API interface for ZingTouch. Contains a constructor for the\n * Region Object, and constructors for each predefined Gesture.\n * @type {Object}\n * @namespace ZingTouch\n */\nlet ZingTouch = {\n  _regions: [],\n\n  // Constructors\n  Gesture,\n  Pan,\n  Distance,\n  Rotate,\n  Swipe,\n  Tap,\n  Region: function(element, capture, preventDefault) {\n    let id = ZingTouch._regions.length;\n    let region = new Region(element, capture, preventDefault, id);\n    ZingTouch._regions.push(region);\n    return region;\n  },\n};\n\nexport default ZingTouch;\n","/**\n * @file main.js\n * Main file to setup event listeners on the document,\n * and to expose the ZingTouch object\n */\n\nimport ZingTouch from './../ZingTouch.js';\n\nif (typeof window !== 'undefined') {\n  window.ZingTouch = ZingTouch;\n}\n\nexport default ZingTouch;\n"],"sourceRoot":""}